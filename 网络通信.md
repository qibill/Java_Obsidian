### 七层模型
1. 物理层
2. 链路层
3. 网络层
4. 传输层 
    - TCP 传输控制协议
    - UDP 用户数据报协议
5. 会话层
    - RPC
6. 表示层
7. 应用层


### 1. TCP/IP 五层模型

![image](https://img-blog.csdnimg.cn/20200904160558176.png)

### 2. 浏览器输入地址后做了什么？

![image](https://img-blog.csdnimg.cn/20200904160558322.png)

### 3. 三次握手与四次挥手

*   三次握手

![image](https://img-blog.csdnimg.cn/20200904160558436.png)

*   四次挥手

![image](https://img-blog.csdnimg.cn/20200904160558571.png)

### 4. TIME\_WAIT 与 CLOSE\_WAIT

![image](https://img-blog.csdnimg.cn/20200904160558691.png)

### 5. TCP 滑动窗口

TCP 流量控制，主要使用**滑动窗口协议**，滑动窗口是接受数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。这个窗口大小就是我们一次传输几个数据。对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。

### 6. TCP 粘包和拆包

*   现象
    ![image](https://img-blog.csdnimg.cn/20200904160558786.png)
*   产生原因
    1.  要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
    2.  待发送数据大于 MSS（最大报文长度），TCP
    3.  要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
    4.  接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。
*   解决方式
    1.  发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
    2.  发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
    3.  可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。

### HTTP
#### 响应结构
HTTP 请求的组成
- 状态行
- 请求头
- 消息主体

HTTP 响应的组成
- 状态行
- 响应头
- 响应正文

#### 状态码
- 1xx：指示消息--表示请求已接收，继续处理
- 2xx：成功--表示请求已被成功接收、理解、接受
- 3xx: 重定向--要完成请求必须进行更进一步的操作
- 4xx：客户端错误--请求有语法错误或请求无法实现
- 5xx: 服务器端错误--服务端未能实现合法的请求