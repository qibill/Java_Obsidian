### 一、Spring事务隔离级别

Spring事务隔离级别比数据库事务隔离级别多一个default

1) DEFAULT （默认）
这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。

2) READ_UNCOMMITTED （读未提交）
这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。

3) READ_COMMITTED （读已提交）
保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。

4) REPEATABLE_READ （可重复读）
这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了不可重复读。

5) SERIALIZABLE（串行化）
这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读、不可重复读外，还避免了幻像读。 

### 二、Spring事务传播属性
默认 **PROPAGATION\_REQUIRED** ，如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。
![image](https://img-blog.csdn.net/20170420212829825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29vbmZseQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**propagation（单词含义：传播）**

#### 1. propagation_required（传播）

从这个单词的中文翻译我们可以得出以下结论，事务（@Transtational）使用该类型时，如果当前不存在事务则需要创建一个新的事务去进行，如果当前存在事务就加入到这个事务当中去。
#### 2. propagation_supports（需要支持，那么既然它这里都说了只是支持，也就是说没有很强烈的指定一个事务行为可以理解为“双标”）

从这个单词的中文翻译我们可以得出以下结论：事务使用该类型时，会出现以下情况，如果当前存在事务，我就以事务的方式去执行，如果当前不存在事务，我就以没有事务的方式去进行任务。
#### 3. propagation_mandatory（强制，这里指明了很强烈的语气）

从这个单词我们可以的得出，该行为具有以下特征：如果当前存在事务，我就执行当前事务，如果当前不存在事务，我们就抛出异常，任性！
#### 4. propagation_required_new（需要新的，说明我需要一个新的事务）

从这个单词我们可以得出，如果当前没有事务我就新建一个事务，如果当前存在事务，就像当前事务挂起，再新建事务，反正我一定要新建一个事务。
#### 5. propagation_not_supports（不支持，我不支持事务，但是我没有强烈反对）

从这个单词我们可以得出，如果当前存在事务，那么我就将当前事务挂起，我现在当前这个任务按照没有事务的方式进行下去，不管怎么样，我就是要按照没有事务的方式进行下去，但是我也不破坏别人的运行结构。
#### 6.propagation_never（从来不，我不需要任何事务，语气很强烈）

从这个单词我们可以得出，我不管怎么样，我就是要无事务的方式进行执行，如果当前存在事务我就要抛出异常，一定要影响他人的程序运行结果。
#### 7. propagation_nested（嵌套，我可以在事务中在创建一个事务）

从这个单词我们可以得出，如果当前存在事务，然后运行到我这里，我就自己另起一个事务，我的事情不需要其他人来管理，我自己的事情可以自己解决，但是我也不破坏别人的运行结构，然后如果当前没有事务，我也会自己创建一个事务来管理我自己。总体来说就是有事务就嵌套，没事务就自己创建。

