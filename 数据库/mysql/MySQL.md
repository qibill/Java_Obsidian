### 1. 聚簇索引与非聚簇索引

![image](https://img-blog.csdnimg.cn/20200904160557515.png)

*   都使用 B+ 树作为数据结构
*   聚簇索引中数据存在主键索引的叶子结点中，得到 key 即得到 data ；非聚簇索引的数据存在单独的空间。
*   聚簇索引中辅助索引的叶子结点存的是主键；非聚簇索引中叶子结点存的是数据的地址；
*   聚簇索引的优势是找到主键就找到数据，只需一次磁盘 IO ；当 B+ 树的结点发生变化时，地址也会发生变化，这时非聚簇索引需要更新所有的地址，增加开销。

### 2. 为何使用 B 树做索引而不是红黑树？

索引很大，通常作为文件存储在磁盘上面，每次检索索引都需要把索引文件加载进内存，所以磁盘 IO 的次数是衡量索引数据结构好坏的重要指标。应用程序在从磁盘读取数据时，不只是读取需要的数据，还会连同其他数据以页的形式做预读来减少磁盘 IO 的次数。数据库的设计者将每个节点的大小设置为一页的大小，同时每次新建节点时都重新申请一个页，这样检索一个节点只需要一次 IO，根据索引定位到数据只需要 h- 1（h 为 B 树高度，根节点常驻内存） 次 IO，而 d (度，可以理解为宽度)与 h 称反比，即 d 越大，高度就越小，所以树越扁，磁盘 IO 次数越少，即渐进复杂度为 logdN ，这也是为什么不选择红黑树做索引的原因。前面可以得出结论，d 越大，索引的性能越好。节点由 key 和 data 组成，页的大小一定，key 和 data 越小，d 越大。B + 树去掉了节点内的 data 域，所以有更大的 d , 性能更好。

### 3. 最左前缀原则

在 MySQL 中，可以指定多个列为索引，即联合索引。比如 index(name，age) ，最左前缀原则是指查询时精确匹配到从最左边开始的一列或几列（name；name\&age），就可以命中索引。如果所有列都用到了，顺序不同，查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。

### 4. 什么情况下可以用到 B 树索引

1.  定义有主键的列一定要建立索引。因为主键可以加速定位到表中的某行

2.  定义有外键的列一定要建立索引。外键列通常用于表与表之间的连接，在其上创建索引可以加快表间的连接

3.  对于经常查询的数据列最好建立索引。

    1.  对于需要在指定范围内快速或频繁查询的数据列，因为索引已经排序，其指定的范围是连续的，查询可以利用索引的排序，加快查询的时间
    2.  经常用在 <code>where</code> 子句中的数据列，将索引建立在 <code>where</code> 子句的集合过程中，对于需要加速或频繁检索的数据列，可以让这些经常参与查询的数据列按照索引的排序进行查询，加快查询的时间。

### 5. 事务隔离级别

*   Read uncommitted 读未提交，可能出现脏读，不可重复读，幻读。
*   Read committed 读提交，可能出现不可重复读，幻读。
*   Repeatable read 可重复读，可能出现脏读。
*   Serializable 可串行化，同一数据读写都加锁，避免脏读，性能不忍直视。

<blockquote>Inno DB 默认隔离级别为可重复读级别，分为快照度和当前读，并且通过行锁和间隙锁解决了幻读问题。</blockquote>

### 6. MVCC （多版本并发控制）

*   实现细节
    *   每行数据都存在一个版本，每次数据更新时都更新该版本。
    *   修改时 Copy 出当前版本随意修改，各个事务之间互不干扰。
    *   保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃 copy（rollback）。
*   Inno DB 实现

<blockquote>在 InnoDB 中为每行增加两个隐藏的字段，分别是该行数据创建时的版本号和删除时的版本号，这里的版本号是系统版本号（可以简单理解为事务的 ID），每开始一个新的事务，系统版本号就自动递增，作为事务的 ID 。通常这两个版本号分别叫做创建时间和删除时间。</blockquote>

详细参考：[《脏读、幻读和不可重复读》](https://aysaml.com/articles/2020/01/04/1578137608006.html)